# 用户行为分析漏斗图设计文档

## 1. 需求分析

### 1.1 功能需求
基于用户提供的截图，需要实现一个复杂的用户行为分析漏斗图，具备以下特征：

- **流程步骤展示**：显示用户行为的关键步骤
- **数据统计**：每个步骤的参与人数和转化率
- **时间信息**：每个步骤的耗时统计
- **可视化效果**：漏斗图形式展示转化过程

### 1.2 具体示例
从截图可以看到的漏斗图结构：
```
漏斗图_成功率与转化时长

左侧流程步骤：
- 第一步：流程开始 (15分钟)
- 第二步：发起余额分账 (15分钟)  
- 第二步：完成分账 (5分钟)

右侧数据展示：
- 流程开始：500 (100%)
- 发起余额分账：100 (20%)
- 完成分账：100 (10%)
```

### 1.3 核心功能点
1. **用户行为路径分析**：追踪用户在应用中的行为序列
2. **转化率计算**：计算每个步骤相对于起始步骤的转化率
3. **时间统计**：统计每个步骤的平均耗时
4. **智能识别**：AI自动识别用户行为流程
5. **自定义配置**：支持用户自定义流程步骤

## 2. 系统架构设计

### 2.1 整体架构
```
用户输入需求 → AI需求解析 → 数据获取 → 行为分析 → 漏斗图生成 → 可视化展示
```

### 2.2 核心组件

#### 2.2.1 数据处理器层
- **BehaviorAnalysisDataProcessor**：用户行为分析数据处理器
- **FunnelDataProcessor**：漏斗图数据处理器
- **TimeAnalysisProcessor**：时间分析处理器

#### 2.2.2 图表生成层
- **BehaviorFunnelGenerator**：行为漏斗图生成器
- **ConversionFunnelGenerator**：转化漏斗图生成器
- **TimeFunnelGenerator**：时间漏斗图生成器

#### 2.2.3 AI分析层
- **BehaviorRequirementParser**：行为需求解析器
- **FlowStepExtractor**：流程步骤提取器
- **ConversionAnalyzer**：转化分析器

## 3. 数据模型设计

### 3.1 双埋点数据模型
基于现有系统的埋点架构，漏斗图需要整合两种类型的数据：

#### 3.1.1 用户访问埋点数据
```javascript
// 页面访问记录 (visitBuryPointId) - 基于真实数据结构
{
  "id": 1954,
  "pageName": "下级商户查询-appid 配置",
  "type": "页面",
  "stayTime": "0", // 停留时间(秒)
  "pageBehavior": "打开", // 页面行为：打开/关闭
  "weCustomerKey": "a2c03b17-e750-474d-bea0-8d62c5ecb95a-20251010195724499", // 用户唯一标识
  "weUserId": "10091337639", // 用户ID
  "wePath": "https://mp.yeepay.com/mp-galaxy/mp-merchant-access/#/standardMerchantManage/queryMerchant/aggregatePaySetting",
  "weDeviceName": "PC",
  "wePlatform": "Win32",
  "weSystem": "web",
  "weOs": "web",
  "weBrowserName": "chrome",
  "weNewStatus": 2,
  "weIp": "10.201.77.173",
  "weCountry": "0",
  "weProvince": "0",
  "weCity": "内网IP",
  "createdAt": "2025-10-23T01:28:25.000Z"
}
```

#### 3.1.2 按钮点击埋点数据
```javascript
// 按钮点击记录 (clickBuryPointId) - 基于真实数据结构
{
  "id": 7645,
  "pageName": "企业付款-复核申请查询",
  "type": "query", // 点击类型：query(查询)、click(点击)等
  "content": "{\"申请时间\":\"其他\",\"状态\":\"全部\"}", // 点击内容，可能是JSON格式
  "weCustomerKey": "7fabd6dd-e0ab-4bc5-a1de-a7c37f66b12b-20240918130427138", // 用户唯一标识
  "weUserId": "10090768861", // 用户ID
  "wePath": "https://mp.yeepay.com/mp-galaxy/mp-boss-fundmanage/#/companyPay/apply",
  "weDeviceName": "PC",
  "wePlatform": "Win32",
  "weSystem": "web",
  "weOs": "web",
  "weBrowserName": "chrome",
  "weNewStatus": 2,
  "weIp": "10.201.73.202",
  "weCountry": "0",
  "weProvince": "0",
  "weCity": "内网IP",
  "createdAt": "2025-10-22T06:27:47.000Z"
}
```

#### 3.1.3 用户行为路径数据模型
```javascript
// 整合后的用户行为路径 - 基于真实数据结构
{
  weCustomerKey: "a2c03b17-e750-474d-bea0-8d62c5ecb95a-20251010195724499",
  weUserId: "10091337639",
  behaviorPath: [
    {
      step: 1,
      stepName: "流程开始",
      actionType: "visit", // visit(页面访问) 或 click(按钮点击)
      pageName: "下级商户查询-appid 配置",
      content: null, // 访问时为空，点击时为按钮内容
      type: "页面", // 原始type字段
      pageBehavior: "打开", // 页面行为
      stayTime: "0", // 停留时间
      timestamp: "2025-10-23T01:28:25.000Z",
      wePath: "https://mp.yeepay.com/mp-galaxy/mp-merchant-access/#/standardMerchantManage/queryMerchant/aggregatePaySetting"
    },
    {
      step: 2,
      stepName: "发起查询操作", 
      actionType: "click",
      pageName: "企业付款-复核申请查询",
      content: "{\"申请时间\":\"其他\",\"状态\":\"全部\"}", // JSON格式的查询条件
      type: "query", // 原始type字段
      timestamp: "2025-10-22T06:27:47.000Z",
      wePath: "https://mp.yeepay.com/mp-galaxy/mp-boss-fundmanage/#/companyPay/apply"
    },
    {
      step: 3,
      stepName: "完成操作",
      actionType: "visit", 
      pageName: "下级商户查询-appid 配置",
      content: null,
      type: "页面",
      pageBehavior: "关闭", // 页面关闭
      stayTime: "11", // 停留11秒
      timestamp: "2025-10-23T01:28:35.000Z",
      wePath: "https://mp.yeepay.com/mp-galaxy/mp-merchant-access/#/standardMerchantManage/queryMerchant"
    }
  ],
  totalDuration: 10, // 总耗时(秒) - 从第一个打开到最后一个关闭
  isCompleted: true, // 是否完成整个流程
  deviceInfo: {
    weDeviceName: "PC",
    wePlatform: "Win32",
    weSystem: "web",
    weOs: "web",
    weBrowserName: "chrome"
  }
}
```

### 3.2 流程步骤数据模型
```javascript
// 流程步骤定义
{
  stepId: "step_1",
  stepName: "流程开始",
  stepType: "entry", // entry, process, exit
  expectedDuration: 15, // 分钟
  description: "用户进入流程的起始步骤"
}
```

### 3.3 漏斗图数据模型
```javascript
// 漏斗图数据
{
  funnelId: "funnel_123",
  funnelName: "余额分账流程",
  steps: [
    {
      stepId: "step_1",
      stepName: "流程开始",
      participantCount: 500,
      conversionRate: 100, // 相对于起始步骤的百分比
      averageDuration: 15, // 分钟
      timeRange: "2025-01-01 到 2025-01-07"
    },
    {
      stepId: "step_2", 
      stepName: "发起余额分账",
      participantCount: 100,
      conversionRate: 20,
      averageDuration: 15,
      timeRange: "2025-01-01 到 2025-01-07"
    },
    {
      stepId: "step_3",
      stepName: "完成分账", 
      participantCount: 100,
      conversionRate: 10,
      averageDuration: 5,
      timeRange: "2025-01-01 到 2025-01-07"
    }
  ],
  totalParticipants: 500,
  overallConversionRate: 10,
  averageTotalDuration: 35 // 分钟
}
```

## 4. 核心算法设计

### 4.1 双埋点数据组织算法
这是最关键的部分，需要将访问埋点和点击埋点数据整合成用户行为路径：

```javascript
class DualBuryPointDataOrganizer {
  /**
   * 整合访问埋点和点击埋点数据
   * @param {Array} visitData - 访问埋点数据
   * @param {Array} clickData - 点击埋点数据
   * @returns {Array} 用户行为路径数组
   */
  organizeUserBehaviorPaths(visitData, clickData) {
    // 1. 按用户分组所有数据
    const userDataMap = new Map();
    
    // 处理访问数据
    visitData.forEach(record => {
      const userKey = record.weCustomerKey;
      if (!userDataMap.has(userKey)) {
        userDataMap.set(userKey, {
          weCustomerKey: userKey,
          weUserId: record.weUserId,
          actions: [],
          deviceInfo: {
            weDeviceName: record.weDeviceName,
            wePlatform: record.wePlatform,
            weSystem: record.weSystem,
            weOs: record.weOs,
            weBrowserName: record.weBrowserName
          }
        });
      }
      
      userDataMap.get(userKey).actions.push({
        type: 'visit',
        pageName: record.pageName,
        pageBehavior: record.pageBehavior,
        stayTime: record.stayTime,
        timestamp: new Date(record.createdAt),
        wePath: record.wePath,
        originalData: record
      });
    });
    
    // 处理点击数据
    clickData.forEach(record => {
      const userKey = record.weCustomerKey;
      if (!userDataMap.has(userKey)) {
        userDataMap.set(userKey, {
          weCustomerKey: userKey,
          weUserId: record.weUserId,
          actions: [],
          deviceInfo: {
            weDeviceName: record.weDeviceName,
            wePlatform: record.wePlatform,
            weSystem: record.weSystem,
            weOs: record.weOs,
            weBrowserName: record.weBrowserName
          }
        });
      }
      
      userDataMap.get(userKey).actions.push({
        type: 'click',
        pageName: record.pageName,
        content: record.content,
        clickType: record.type, // query, click等
        timestamp: new Date(record.createdAt),
        wePath: record.wePath,
        originalData: record
      });
    });
    
    // 2. 为每个用户构建行为路径
    const userPaths = [];
    userDataMap.forEach((userData, userKey) => {
      // 按时间排序所有行为
      userData.actions.sort((a, b) => a.timestamp - b.timestamp);
      
      // 构建行为路径
      const behaviorPath = this.buildBehaviorPath(userData.actions);
      
      userPaths.push({
        weCustomerKey: userKey,
        weUserId: userData.weUserId,
        behaviorPath: behaviorPath,
        totalDuration: this.calculateTotalDuration(behaviorPath),
        isCompleted: this.isPathCompleted(behaviorPath),
        deviceInfo: userData.deviceInfo
      });
    });
    
    return userPaths;
  }
  
  /**
   * 构建用户行为路径
   * @param {Array} actions - 按时间排序的用户行为
   * @returns {Array} 行为路径
   */
  buildBehaviorPath(actions) {
    const path = [];
    let stepCounter = 1;
    
    for (let i = 0; i < actions.length; i++) {
      const action = actions[i];
      const nextAction = actions[i + 1];
      
      // 识别步骤名称
      const stepName = this.identifyStepName(action, nextAction);
      
      path.push({
        step: stepCounter++,
        stepName: stepName,
        actionType: action.type,
        pageName: action.pageName,
        content: action.content || null,
        type: action.clickType || '页面',
        pageBehavior: action.pageBehavior || null,
        stayTime: action.stayTime || null,
        timestamp: action.timestamp.toISOString(),
        wePath: action.wePath,
        originalData: action.originalData
      });
    }
    
    return path;
  }
  
  /**
   * 识别步骤名称
   * @param {Object} currentAction - 当前行为
   * @param {Object} nextAction - 下一个行为
   * @returns {String} 步骤名称
   */
  identifyStepName(currentAction, nextAction) {
    if (currentAction.type === 'visit') {
      if (currentAction.pageBehavior === '打开') {
        return '流程开始';
      } else if (currentAction.pageBehavior === '关闭') {
        return '流程结束';
      } else {
        return `访问${currentAction.pageName}`;
      }
    } else if (currentAction.type === 'click') {
      // 尝试从content中提取操作名称
      if (currentAction.content) {
        try {
          const contentObj = JSON.parse(currentAction.content);
          if (contentObj.申请时间 || contentObj.状态) {
            return '发起查询操作';
          }
        } catch (e) {
          // 如果不是JSON，直接使用content
          return currentAction.content;
        }
      }
      return `点击操作`;
    }
    
    return '未知步骤';
  }
  
  /**
   * 计算总耗时
   * @param {Array} behaviorPath - 行为路径
   * @returns {Number} 总耗时(秒)
   */
  calculateTotalDuration(behaviorPath) {
    if (behaviorPath.length < 2) return 0;
    
    const startTime = new Date(behaviorPath[0].timestamp);
    const endTime = new Date(behaviorPath[behaviorPath.length - 1].timestamp);
    
    return Math.floor((endTime - startTime) / 1000); // 转换为秒
  }
  
  /**
   * 判断路径是否完成
   * @param {Array} behaviorPath - 行为路径
   * @returns {Boolean} 是否完成
   */
  isPathCompleted(behaviorPath) {
    // 简单判断：如果有打开和关闭操作，认为完成
    const hasOpen = behaviorPath.some(step => step.pageBehavior === '打开');
    const hasClose = behaviorPath.some(step => step.pageBehavior === '关闭');
    
    return hasOpen && hasClose;
  }
}
```

### 4.2 用户行为路径分析算法
```javascript
class BehaviorPathAnalyzer {
  // 分析用户行为路径
  analyzeUserPath(userActions) {
    // 1. 按时间排序用户行为
    // 2. 识别关键行为节点
    // 3. 计算步骤间的时间间隔
    // 4. 统计每个步骤的参与人数
  }
  
  // 识别流程步骤
  identifyFlowSteps(actions) {
    // 1. 使用AI识别关键步骤
    // 2. 基于行为模式匹配
    // 3. 支持自定义步骤定义
  }
}
```

### 4.2 转化率计算算法
```javascript
class ConversionRateCalculator {
  // 计算转化率
  calculateConversionRate(stepData) {
    const baseCount = stepData[0].participantCount;
    return stepData.map(step => ({
      ...step,
      conversionRate: (step.participantCount / baseCount) * 100
    }));
  }
  
  // 计算步骤间转化率
  calculateStepConversionRate(currentStep, previousStep) {
    return (currentStep.participantCount / previousStep.participantCount) * 100;
  }
}
```

### 4.3 时间分析算法
```javascript
class TimeAnalyzer {
  // 计算平均耗时
  calculateAverageDuration(actions, stepDefinition) {
    // 1. 识别步骤开始和结束时间
    // 2. 计算每个用户的步骤耗时
    // 3. 计算平均耗时
  }
  
  // 分析时间分布
  analyzeTimeDistribution(durations) {
    // 1. 计算中位数、四分位数
    // 2. 识别异常值
    // 3. 生成时间分布统计
  }
}
```

## 5. AI集成设计

### 5.1 需求解析提示词
```javascript
const BEHAVIOR_ANALYSIS_PROMPT = `
你是一个用户行为分析专家。请分析用户的需求，识别用户想要分析的行为流程。

用户需求："{userRequirement}"

请返回JSON格式的分析结果：
{
  "intent": "behavior_funnel_analysis",
  "chartType": "behavior_funnel",
  "description": "用户行为转化漏斗分析",
  "flowSteps": [
    {
      "stepName": "步骤名称",
      "stepType": "entry|process|exit",
      "keywords": ["关键词1", "关键词2"],
      "expectedDuration": 15
    }
  ],
  "confidence": 0.95
}
`;
```

### 5.2 流程步骤识别
```javascript
const FLOW_STEP_EXTRACTION_PROMPT = `
基于用户行为数据，识别关键的业务流程步骤。

行为数据：{behaviorData}

请识别出完整的业务流程，包括：
1. 流程起始步骤
2. 中间处理步骤  
3. 流程结束步骤

返回JSON格式：
{
  "flowName": "流程名称",
  "steps": [
    {
      "stepName": "步骤名称",
      "stepOrder": 1,
      "triggerActions": ["action1", "action2"],
      "pageNames": ["page1", "page2"]
    }
  ]
}
`;
```

## 6. 图表生成设计

### 6.1 漏斗图配置
基于真实数据结构的漏斗图生成：

```javascript
const generateBehaviorFunnelOption = (funnelData) => {
  return {
    title: {
      text: funnelData.funnelName || '用户行为转化漏斗',
      subtext: `总参与人数: ${funnelData.totalParticipants} | 整体转化率: ${funnelData.overallConversionRate}%`,
      left: 'center',
      textStyle: {
        fontSize: 18,
        fontWeight: 'bold'
      }
    },
    tooltip: {
      trigger: 'item',
      formatter: function(params) {
        const step = funnelData.steps[params.dataIndex];
        return `
          <div style="padding: 10px;">
            <strong style="color: #1890ff;">${step.stepName}</strong><br/>
            <span style="color: #666;">参与人数: </span><strong>${step.participantCount}</strong><br/>
            <span style="color: #666;">转化率: </span><strong style="color: #52c41a;">${step.conversionRate}%</strong><br/>
            <span style="color: #666;">平均耗时: </span><strong style="color: #faad14;">${step.averageDuration}秒</strong>
          </div>
        `;
      }
    },
    series: [{
      name: '行为转化漏斗',
      type: 'funnel',
      left: '10%',
      top: 80,
      bottom: 60,
      width: '80%',
      min: 0,
      max: funnelData.totalParticipants,
      minSize: '0%',
      maxSize: '100%',
      sort: 'descending',
      gap: 2,
      label: {
        show: true,
        position: 'inside',
        formatter: function(params) {
          const step = funnelData.steps[params.dataIndex];
          return `${step.stepName}\n${step.participantCount} (${step.conversionRate}%)`;
        },
        fontSize: 12,
        fontWeight: 'bold',
        color: '#fff'
      },
      labelLine: {
        length: 10,
        lineStyle: {
          width: 1,
          type: 'solid'
        }
      },
      itemStyle: {
        borderColor: '#fff',
        borderWidth: 2
      },
      emphasis: {
        label: {
          fontSize: 14
        },
        itemStyle: {
          shadowBlur: 10,
          shadowColor: 'rgba(0, 0, 0, 0.3)'
        }
      },
      data: funnelData.steps.map((step, index) => ({
        value: step.participantCount,
        name: step.stepName,
        itemStyle: {
          color: getStepColor(index)
        }
      }))
    }],
    // 添加时间信息显示
    graphic: funnelData.steps.map((step, index) => ({
      type: 'text',
      left: '85%',
      top: `${80 + (index * 15)}%`,
      style: {
        text: `${step.averageDuration}秒`,
        fontSize: 12,
        fill: '#666',
        fontWeight: 'bold'
      }
    }))
  };
};

// 步骤颜色配置
const getStepColor = (index) => {
  const colors = [
    '#1890ff', // 蓝色 - 流程开始
    '#52c41a', // 绿色 - 中间步骤
    '#faad14', // 橙色 - 关键步骤
    '#f5222d', // 红色 - 结束步骤
    '#722ed1', // 紫色 - 其他步骤
    '#13c2c2', // 青色
    '#eb2f96', // 粉色
    '#fa8c16'  // 深橙色
  ];
  return colors[index % colors.length];
};
```

### 6.2 基于真实数据的漏斗图生成示例
```javascript
// 基于你提供的示例数据生成的漏斗图数据
const exampleFunnelData = {
  funnelId: "funnel_merchant_query",
  funnelName: "商户查询流程转化漏斗",
  steps: [
    {
      stepId: "step_1",
      stepName: "流程开始",
      participantCount: 500, // 假设有500个用户开始流程
      conversionRate: 100, // 起始步骤100%
      averageDuration: 0, // 开始时间
      timeRange: "2025-10-22 到 2025-10-23",
      description: "用户访问下级商户查询页面"
    },
    {
      stepId: "step_2", 
      stepName: "发起查询操作",
      participantCount: 100, // 100个用户进行了查询操作
      conversionRate: 20, // 20%的转化率
      averageDuration: 15, // 平均15秒后发起查询
      timeRange: "2025-10-22 到 2025-10-23",
      description: "用户点击查询按钮，设置查询条件"
    },
    {
      stepId: "step_3",
      stepName: "完成操作", 
      participantCount: 100, // 100个用户完成了操作
      conversionRate: 20, // 相对于起始步骤的转化率
      averageDuration: 10, // 平均10秒完成操作
      timeRange: "2025-10-22 到 2025-10-23",
      description: "用户完成查询并关闭页面"
    }
  ],
  totalParticipants: 500,
  overallConversionRate: 20, // 整体转化率20%
  averageTotalDuration: 25 // 平均总耗时25秒
};
```

### 6.2 时间信息展示
```javascript
const addTimeInfoToFunnel = (option, funnelData) => {
  // 在漏斗图右侧添加时间信息
  option.graphic = funnelData.steps.map((step, index) => ({
    type: 'text',
    left: '85%',
    top: `${60 + (index * 20)}%`,
    style: {
      text: `${step.averageDuration}分钟`,
      fontSize: 12,
      fill: '#666'
    }
  }));
  
  return option;
};
```

## 7. 用户界面设计

### 7.1 行为分析模式界面
在现有的行为分析模式下，添加漏斗图选项：

```javascript
// 在AIChatInterface.vue中添加
const behaviorAnalysisOptions = [
  { 
    text: '🎯 行为转化漏斗', 
    type: 'select_analysis', 
    params: { 
      type: 'behavior_funnel', 
      description: '分析用户行为转化漏斗和关键节点' 
    } 
  },
  { 
    text: '⏱️ 时间漏斗分析', 
    type: 'select_analysis', 
    params: { 
      type: 'time_funnel', 
      description: '分析用户行为各步骤的时间分布' 
    } 
  },
  { 
    text: '📊 自定义流程漏斗', 
    type: 'select_analysis', 
    params: { 
      type: 'custom_funnel', 
      description: '自定义用户行为流程进行漏斗分析' 
    } 
  }
];
```

### 7.2 流程配置界面
```javascript
// 流程步骤配置组件
const FlowStepConfig = {
  template: `
    <div class="flow-step-config">
      <h3>配置流程步骤</h3>
      <div v-for="(step, index) in steps" :key="index" class="step-item">
        <a-input v-model="step.stepName" placeholder="步骤名称" />
        <a-input-number v-model="step.expectedDuration" placeholder="预期耗时(分钟)" />
        <a-button @click="removeStep(index)" type="danger">删除</a-button>
      </div>
      <a-button @click="addStep" type="primary">添加步骤</a-button>
    </div>
  `,
  data() {
    return {
      steps: [
        { stepName: '流程开始', expectedDuration: 15 },
        { stepName: '发起余额分账', expectedDuration: 15 },
        { stepName: '完成分账', expectedDuration: 5 }
      ]
    }
  }
};
```

## 8. 实现计划

### 8.1 第一阶段：核心功能实现
1. **创建数据处理器**
   - 实现 `BehaviorAnalysisDataProcessor`
   - 实现用户行为路径分析算法
   - 实现转化率计算算法

2. **扩展图表生成器**
   - 添加 `generateBehaviorFunnelOption` 方法
   - 实现时间信息展示
   - 实现自定义漏斗图配置

### 8.2 第二阶段：AI集成
1. **扩展需求解析器**
   - 添加行为分析提示词
   - 实现流程步骤识别
   - 集成AI分析功能

2. **智能分析功能**
   - 自动识别用户行为流程
   - 智能计算转化率
   - 自动生成漏斗图

### 8.3 第三阶段：用户界面优化
1. **界面集成**
   - 在行为分析模式下添加漏斗图选项
   - 实现流程配置界面
   - 添加时间范围选择

2. **用户体验优化**
   - 添加交互式配置
   - 实现实时预览
   - 添加导出功能

## 9. 技术难点与解决方案

### 9.1 双埋点数据整合（核心难点）
**难点**：如何将访问埋点和点击埋点数据整合成完整的用户行为路径
**具体挑战**：
- 访问数据：`type: "页面"`, `pageBehavior: "打开/关闭"`, `stayTime: "停留时间"`
- 点击数据：`type: "query"`, `content: "JSON格式的查询条件"`
- 需要按 `weCustomerKey` 和时间顺序整合两种数据

**解决方案**：
```javascript
// 1. 数据预处理和标准化
const preprocessData = (visitData, clickData) => {
  // 统一时间格式
  const normalizeTimestamp = (record) => new Date(record.createdAt);
  
  // 标准化访问数据
  const normalizedVisitData = visitData.map(record => ({
    ...record,
    actionType: 'visit',
    normalizedTimestamp: normalizeTimestamp(record)
  }));
  
  // 标准化点击数据
  const normalizedClickData = clickData.map(record => ({
    ...record,
    actionType: 'click',
    normalizedTimestamp: normalizeTimestamp(record)
  }));
  
  return { normalizedVisitData, normalizedClickData };
};

// 2. 按用户分组并排序
const groupByUser = (visitData, clickData) => {
  const userMap = new Map();
  
  // 合并所有数据
  const allData = [...visitData, ...clickData];
  
  // 按用户分组
  allData.forEach(record => {
    const userKey = record.weCustomerKey;
    if (!userMap.has(userKey)) {
      userMap.set(userKey, []);
    }
    userMap.get(userKey).push(record);
  });
  
  // 按时间排序每个用户的行为
  userMap.forEach(actions => {
    actions.sort((a, b) => a.normalizedTimestamp - b.normalizedTimestamp);
  });
  
  return userMap;
};
```

### 9.2 用户行为路径识别
**难点**：如何从混合的访问和点击数据中识别出有意义的业务流程
**具体挑战**：
- 访问数据中的 `pageBehavior: "打开/关闭"` 需要正确识别
- 点击数据中的 `content` 字段是JSON格式，需要解析
- 需要智能识别步骤名称和流程逻辑

**解决方案**：
```javascript
// 智能步骤识别算法
const identifyFlowSteps = (userActions) => {
  const steps = [];
  let stepCounter = 1;
  
  for (let i = 0; i < userActions.length; i++) {
    const action = userActions[i];
    const nextAction = userActions[i + 1];
    
    let stepName = '未知步骤';
    
    if (action.actionType === 'visit') {
      if (action.pageBehavior === '打开') {
        stepName = '流程开始';
      } else if (action.pageBehavior === '关闭') {
        stepName = '流程结束';
      } else {
        stepName = `访问${action.pageName}`;
      }
    } else if (action.actionType === 'click') {
      // 解析JSON格式的content
      try {
        const contentObj = JSON.parse(action.content);
        if (contentObj.申请时间 && contentObj.状态) {
          stepName = '发起查询操作';
        } else if (contentObj.状态) {
          stepName = '状态筛选';
        } else {
          stepName = '点击操作';
        }
      } catch (e) {
        stepName = action.content || '点击操作';
      }
    }
    
    steps.push({
      step: stepCounter++,
      stepName: stepName,
      actionType: action.actionType,
      pageName: action.pageName,
      content: action.content,
      timestamp: action.normalizedTimestamp,
      stayTime: action.stayTime
    });
  }
  
  return steps;
};
```

### 9.3 时间统计准确性
**难点**：如何准确计算每个步骤的耗时，特别是处理 `stayTime` 字段
**具体挑战**：
- `stayTime` 字段是字符串格式，需要转换为数字
- 需要区分页面停留时间和步骤间的时间间隔
- 处理异常时间数据（如负数、过大值等）

**解决方案**：
```javascript
// 时间计算算法
const calculateStepDurations = (behaviorPath) => {
  return behaviorPath.map((step, index) => {
    let duration = 0;
    
    if (step.actionType === 'visit' && step.stayTime) {
      // 使用页面停留时间
      duration = parseInt(step.stayTime) || 0;
    } else if (index < behaviorPath.length - 1) {
      // 计算到下一步的时间间隔
      const currentTime = new Date(step.timestamp);
      const nextTime = new Date(behaviorPath[index + 1].timestamp);
      duration = Math.floor((nextTime - currentTime) / 1000); // 转换为秒
    }
    
    return {
      ...step,
      duration: Math.max(0, duration), // 确保非负数
      durationFormatted: formatDuration(duration)
    };
  });
};

const formatDuration = (seconds) => {
  if (seconds < 60) {
    return `${seconds}秒`;
  } else if (seconds < 3600) {
    return `${Math.floor(seconds / 60)}分钟${seconds % 60}秒`;
  } else {
    return `${Math.floor(seconds / 3600)}小时${Math.floor((seconds % 3600) / 60)}分钟`;
  }
};
```

### 9.4 转化率计算
**难点**：如何准确计算各步骤间的转化率，处理数据异常情况
**具体挑战**：
- 需要基于 `weCustomerKey` 进行用户去重
- 处理不完整的用户行为路径
- 计算相对于起始步骤的转化率

**解决方案**：
```javascript
// 转化率计算算法
const calculateConversionRates = (userPaths) => {
  // 统计每个步骤的参与人数
  const stepStats = new Map();
  
  userPaths.forEach(userPath => {
    userPath.behaviorPath.forEach(step => {
      const stepKey = step.stepName;
      if (!stepStats.has(stepKey)) {
        stepStats.set(stepKey, {
          stepName: stepKey,
          participantCount: 0,
          totalDuration: 0,
          durations: []
        });
      }
      
      const stats = stepStats.get(stepKey);
      stats.participantCount++;
      if (step.duration) {
        stats.totalDuration += step.duration;
        stats.durations.push(step.duration);
      }
    });
  });
  
  // 计算转化率
  const steps = Array.from(stepStats.values());
  const baseCount = steps[0]?.participantCount || 1; // 起始步骤人数
  
  return steps.map(step => ({
    ...step,
    conversionRate: Math.round((step.participantCount / baseCount) * 100 * 100) / 100, // 保留两位小数
    averageDuration: step.participantCount > 0 ? Math.round(step.totalDuration / step.participantCount) : 0
  }));
};
```

### 9.5 数据质量处理
**难点**：处理真实数据中的各种异常情况
**具体挑战**：
- 时间戳异常（未来时间、过去时间过远）
- 用户标识异常（空值、格式错误）
- 页面行为异常（非标准的打开/关闭值）

**解决方案**：
```javascript
// 数据质量检查和清洗
const validateAndCleanData = (data) => {
  const now = new Date();
  const oneYearAgo = new Date(now.getFullYear() - 1, now.getMonth(), now.getDate());
  const oneDayFromNow = new Date(now.getTime() + 24 * 60 * 60 * 1000);
  
  return data.filter(record => {
    // 检查用户标识
    if (!record.weCustomerKey || record.weCustomerKey.trim() === '') {
      console.warn('发现空的用户标识:', record);
      return false;
    }
    
    // 检查时间戳
    const recordTime = new Date(record.createdAt);
    if (isNaN(recordTime.getTime()) || recordTime < oneYearAgo || recordTime > oneDayFromNow) {
      console.warn('发现异常时间戳:', record);
      return false;
    }
    
    // 检查页面行为
    if (record.pageBehavior && !['打开', '关闭'].includes(record.pageBehavior)) {
      console.warn('发现异常页面行为:', record);
      return false;
    }
    
    return true;
  });
};
```

## 10. 测试策略

### 10.1 单元测试
- 数据处理器功能测试
- 转化率计算准确性测试
- 时间统计功能测试

### 10.2 集成测试
- AI分析功能测试
- 图表生成功能测试
- 用户界面交互测试

### 10.3 性能测试
- 大数据量处理性能测试
- 图表渲染性能测试
- 用户交互响应性能测试

## 11. 扩展性考虑

### 11.1 多维度分析
- 支持按用户群体分析
- 支持按时间段分析
- 支持按设备类型分析

### 11.2 高级功能
- 支持A/B测试对比
- 支持预测分析
- 支持异常检测

### 11.3 数据导出
- 支持多种格式导出
- 支持自定义报表
- 支持定时报告

---

**文档版本**：v1.0  
**创建日期**：2025-01-17  
**作者**：AI Assistant  
**状态**：设计阶段
