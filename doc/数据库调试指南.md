# 数据库调试指南

## 🎯 问题解决

您提出的"双数据库导致调试困难"问题已经解决！

## ✅ 解决方案

### 1. 统一数据库策略
```
开发环境: SQLite (localhost:3004)
生产环境: SQLite (Electron)
```

**不再使用IndexedDB**，所有环境都使用SQLite！

### 2. 新的启动方式

```bash
# 开发环境：同时启动前后端
npm run dev

# 或者分别启动
npm run dev:frontend  # 只启动前端
npm run dev:backend   # 只启动后端
```

### 3. 数据库调试工具

在浏览器控制台中使用：

```javascript
// 检查当前数据库
databaseDebugger.checkConnection()

// 获取数据库统计
databaseDebugger.getStats()

// 清理数据库
databaseDebugger.clearDatabase()

// 导出调试信息
databaseDebugger.exportDebugInfo()
```

## 🔧 调试技巧

### 1. 检查数据库状态
```javascript
// 在浏览器控制台运行
const info = await databaseDebugger.exportDebugInfo()
console.log('数据库信息:', info)
```

### 2. 监控API请求
```javascript
// 查看后端API统计
fetch('http://localhost:3004/api/stats')
  .then(r => r.json())
  .then(console.log)
```

### 3. 清理测试数据
```javascript
// 清理所有数据
await databaseDebugger.clearDatabase()
```

## 📊 数据库结构

### SQLite表结构
```sql
-- 图表配置表
charts (id, name, config, chart_type, created_at, updated_at)

-- 聚合数据表  
chart_data (id, chart_id, date, data, created_at)

-- 原始数据缓存表
raw_data_cache (id, bury_point_id, date, data, created_at)
```

### 索引优化
```sql
-- 性能索引
CREATE INDEX idx_chart_data_chart_id ON chart_data(chart_id);
CREATE INDEX idx_chart_data_date ON chart_data(date);
CREATE INDEX idx_raw_data_cache_bury_point_id ON raw_data_cache(bury_point_id);
```

## 🚀 性能优势

| 特性 | 之前(双数据库) | 现在(统一SQLite) |
|------|---------------|------------------|
| 调试难度 | 困难 | 简单 |
| 数据一致性 | 不一致 | 完全一致 |
| 查询语法 | 两套 | 统一SQL |
| 错误定位 | 复杂 | 简单 |
| 测试覆盖 | 两套 | 一套 |

## 🛠️ 开发流程

### 日常开发
```bash
npm run dev  # 一键启动前后端
```

### 调试问题
1. 打开浏览器控制台
2. 运行 `databaseDebugger.checkConnection()`
3. 查看数据库状态和统计信息
4. 使用SQL查询定位问题

### 性能测试
```bash
# 测试后端API
curl http://localhost:3004/api/stats

# 测试数据聚合
curl -X POST http://localhost:3004/api/aggregate \
  -H "Content-Type: application/json" \
  -d '{"rawData": [...], "chartConfig": {...}}'
```

## 🎉 总结

现在您只需要：
1. **一个数据库**：SQLite
2. **一套查询语法**：SQL
3. **一个调试工具**：databaseDebugger
4. **一致的开发体验**：开发和生产环境完全相同

调试问题变得简单多了！🎯
